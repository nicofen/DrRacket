
;; 02_slow_motion_hdtf_recipe.rkt

; 
; PROBLEM:
; 
; Design a function that consumes a number and produces twice that number. 
; Call your function double. Follow the HtDF recipe and leave behind commented 
; out versions of the stub and template.
; 


; How to Design Functions (HtDF)
; To design a single function.
; ----------------------------
; Signature, purpose, stub
; - The signature tells what type of data a function consumes and what type of data it produces.
; - Purpose is a 1 line description of what the function produces in terms of what it consumes.
; - The stub is like a piece of scaffolding that is put in place for a short period of time. It
;   is going to help us with some other parts of our work. Later commented or deleted.
; Examples (wrapped in check-expects)
; - Examples help us understand what the function must do.
; - Multiple examples to illustrate behavior.
; - Wrapping in check-expect means they will also serve as unit tests for the completed function.
; Inventory - template & constants
; - The template is a function with the right function name and the right parameter.
; - The role of the template is to give us the outline of the function.
; Code body
; - Apply knowledge gained through the process to implement code addressing the intended purpose. 
; Test and Debug
; - Run the tests. Get them to pass. We'll see later what to do when the tests don't pass.
;
; Every step of the recipe helps with the steps after it! To know what to write at one step of
; the recipe, look at what you wrote at the previous steps of the recipe! That's how the recipe
; assists you. It is helping slowly build up the knowledge you need to design the final function.

; To form a signature:
; - Type ... -> Type
; - Declares type of data function consumes and produces.
; - For now, primitive types are: Number, Integer, Natural, String, Image, Boolean

;; Number -> Number                   Signature
;; produce 2 times the given number   Purpose

; Notes:
; - (read as) The function consumes a Number and produces a Number
; - The signature and the purpose are permanently commented out so we start each
;   line with ;;(SPACE) to distinguish them from other comments
; - The purpose needs to say more than the signature.
; - We want the purpose to be short

; Examples/tests
; - We're using two examples to really illustrate that I don't just mean integers.
; - We initially use the stub to ensure that the check-expect examples are well-formed.
; - check-expect checks whether this call to a function... produces the provided result
;
(check-expect (double 3) 6) ;              Examples
(check-expect (double 4.2) 8.4)

; Stub is a function definition that:
; - has the correct function name
; - has correct number of parameters
; - produces dummy result of correct type
;
; The stub is letting us be sure that the tests actually run. (Test Driven Development)
; Write the minimal amount of code for the test to run and check the failing test output
;
; You'll see later as programs start to get big, that making sure all your tests are well
; formed – before you get further along in the process – is a good thing to do, because
; the sooner you find a mistake, the easier it is to fix.
;
;(define (double n) 0)                     Stub

; The body of the template is the outline of the function.
; - For now, the body of the template is (... x) where x is the parameter to the function.
; - Read that as saying, the outline of the function is doing something – that's what the
;   dots mean – with the parameter n. We'll keep a commented copy for reference.
;
;(define (double n)                        Template
;  (... n))

; Code function body
; - Use everything written before to know how to complete the function body. It sometimes
;   helps to elaborate examples to show how the expected value could have been produced.
;
(define (double n) ;                       Function Body
  (* 2 n))
